#!/usr/bin/env perl

use strict;
use warnings;

use utf8;

use open qw(:std :encoding(UTF-8));

use CHI;
use File::Basename;
use File::HomeDir;
use File::Spec;
use Gedcom;
use Geo::Coder::Free;
use Geo::Coder::List;
use Geo::Coder::OSM;
use HTML::GoogleMaps::V3;
use HTML::OSM;

# Configuration
my $gedcom_file = $ARGV[0] or die "Usage: $0 <gedcom_file>\n";
my $output_file = $ARGV[1] || 'events_map.html';
my $google_key = $ENV{GMAP_WEBSITE_KEY};

# Initialize GEDCOM parser
my $ged = Gedcom->new(gedcom_file => $gedcom_file, read_only => 1);

# Initialize geocoder
# my $geocoder = Geo::Coder::OSM->new();
my $cache_dir;
if(my $e = $ENV{'CACHE_DIR'}) {
	$cache_dir = File::Spec->catfile($e, basename($0));
} else {
	# $cache_dir = File::Spec->catfile(File::Spec->tmpdir(), 'cache', basename($0));
	$cache_dir = File::Spec->catfile(File::HomeDir->my_home(), '.cache', basename($0));
}
my $geocoder = Geo::Coder::List->new(
	cache => CHI->new(
		driver => 'File',
		root_dir => $cache_dir,
		l1_cache => { driver => 'RawMemory', global => 1, max_size => 1024*1024 }
	),
	# debug => 1
)->push(Geo::Coder::Free::Local->new())->push(Geo::Coder::Free->new())->push(Geo::Coder::OSM->new());

# Storage for events
my @events;

print "Parsing GEDCOM file...\n";

# Process all individuals
foreach my $indi ($ged->individuals) {
	my $name = $indi->name || 'Unknown';
	$name =~ s/\///g;	# Remove GEDCOM name delimiters

	# Birth events
	if (my $birth = $indi->birth) {
		if (ref($birth) && (my $place = $birth->place)) {
			push @events, {
				type => 'birth',
				name => $name,
				place => $place,
				date => $birth->date || 'Unknown date',
			};
		}
	}

	# Death events
	if (my $death = $indi->death) {
		if (ref($death) && (my $place = $death->place)) {
			push @events, {
				type => 'death',
				name => $name,
				place => $place,
				date => $death->date || 'Unknown date',
			};
		}
	}
}

# Process all families (marriages)
foreach my $fam ($ged->families) {
	my $husband = $fam->husband ? ($fam->husband->name || 'Unknown') : 'Unknown';
	my $wife = $fam->wife ? ($fam->wife->name || 'Unknown') : 'Unknown';
	$husband =~ s/\///g;
	$wife =~ s/\///g;

	if (my $marriage = $fam->marriage) {
		if (ref($marriage) && (my $place = $marriage->place)) {
			push @events, {
				type => 'marriage',
				name => "$husband & $wife",
				place => $place,
				date => $marriage->date || 'Unknown date',
			};
		}
	}
}

print 'Found ', scalar(@events), " events with location data.\n";
print "Geocoding locations...\n";

# Geocode all events
my @geocoded_events;
my %cache;

foreach my $event (@events) {
	my $place = $event->{place};

	# Check cache
	unless (exists $cache{$place}) {
		my $location = $geocoder->geocode(location => $place);
		if ($location && $location->{lat} && $location->{lon}) {
			$cache{$place} = {
				lat => $location->{lat},
				lon => $location->{lon},
			};
			print "\tGeocoded: $place\n";
			sleep 1 if($location->{'geocoder'} !~ /^Geo::Coder::Free/);	# Be nice to geocoding service

		} else {
			print "\tFailed to geocode: $place\n";
			$cache{$place} = undef;
			sleep 1;	# Be nice to geocoding service
		}
	}

	if ($cache{$place}) {
		push @geocoded_events, {
			%$event,
			lat => $cache{$place}{lat},
			lon => $cache{$place}{lon},
		};
	}
}

print 'Successfully geocoded ', scalar(@geocoded_events), " events.\n";
print "Generating map...\n";

# Generate map based on available API key
if ($google_key) {
	generate_google_map(\@geocoded_events, $output_file, $google_key);
} else {
	generate_osm_map(\@geocoded_events, $output_file);
}

print "Map saved to $output_file\n";

# Generate Google Maps
sub generate_google_map {
	my ($events, $file, $key) = @_;

	my $map = HTML::GoogleMaps::V3->new(
		key => $key,
		height => '600px',
		width => '100%',
	);

	# Add markers for each event
	foreach my $event (@$events) {
		my $icon = $event->{type} eq 'birth' ? "\N{U+1F7E2}" :
					$event->{type} eq 'death' ? "\N{U+1F534}" : "\N{U+1F535}";

		my $html = sprintf(
			"<b>%s</b><br>%s<br>%s<br>%s",
			ucfirst($event->{type}),
			$event->{name},
			$event->{date},
			$event->{place}
		);

		$map->add_marker(
			# icon => $icon,
			point => [$event->{lat}, $event->{lon}],
			html => $html,
		);
	}

	# Center map on first event
	if (@$events) {
		$map->center([$events->[0]{lat}, $events->[0]{lon}]);
		$map->zoom(4);
	}

	# Generate and save HTML
	open my $fh, '>', $file or die "Cannot open $file: $!";
	print $fh render($map);
	close $fh;
}

# Generate OpenStreetMap using HTML::OSM
sub generate_osm_map {
	my ($events, $file) = @_;

	# Calculate center point
	my ($lat_sum, $lon_sum) = (0, 0);
	foreach (@$events) {
		$lat_sum += $_->{lat};
		$lon_sum += $_->{lon};
	}
	my $center_lat = @$events ? $lat_sum / @$events : 0;
	my $center_lon = @$events ? $lon_sum / @$events : 0;

	# Create HTML::OSM object
	my $osm = HTML::OSM->new(
		lat => $center_lat,
		lon => $center_lon,
		zoom => 4,
	);

	# Add markers for each event
	foreach my $event (@$events) {
		my $icon = $event->{type} eq 'birth' ? "\N{U+1F7E2}" :
					$event->{type} eq 'death' ? "\N{U+1F534}" : "\N{U+1F535}";

		my $html = sprintf(
			'<b>%s</b><br>%s<br>%s<br>%s',
			ucfirst($event->{type}),
			$event->{name},
			$event->{date},
			$event->{place}
		);

		$osm->add_marker(
			point => [$event->{lat}, $event->{lon}],
			html => $html,
			# icon => $icon,
		);
	}

	# Generate and save HTML
	open my $fh, '>', $file or die "Cannot open $file: $!";
	print $fh render($osm);
	close $fh;
}

# Generate HTML
sub render {
	my $map = $_[0];
	my ($head, $body) = $map->onload_render();

	my $html = <<"HTML";
<!DOCTYPE html>
<html>
<head>
	<title>GEDCOM Events Map</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
		#map { height: 100vh; width: 100%; }
	</style>
	$head
</head>
<body>
	<div id="map">
	$body
	</div>
</body>
</html>
HTML

	return $html;
}
